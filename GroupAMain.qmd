---
title: "ST558 Project 1: Group A"
author: "Eric Song & Jay Thakur"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

*Loading required libraries, include = FALSE.*

```{r, include=FALSE}
library(tidyverse)
library(httr)
library(tidycensus)
library(jsonlite)
```

### Next, write a helper function to take what is returned by GET() and turn it into a nice tibble.

###### ??? idk what this means

##### I think something like this. I called this function in the end of api_fun

```{r}
convert_to_tibble <- function(response) {
  json_content <- fromJSON(rawToChar(response$content))
  as_tibble(json_content[-1, ]) |>
    setNames(json_content[1, ])
}

```

```{r}
get_time <- function(variable) {
  url <- paste0("https://api.census.gov/data/2022/acs/acs1/pums/variables/", variable, ".json")
  response <- GET(url)
  
  if (status_code(response) != 200) {
    stop("error for: ", variable)
  }
  
  temp_list <- fromJSON(rawToChar(response$content))
  time_info <- temp_list$values$item
  time_catg_info <- time_info[sort(names(time_info))]
  
  return(time_catg_info)
}

convert_time_code <- function(code, time_catg_info) {
  if (code %in% names(time_catg_info)) {
    # extract the time range as a string
    time_range <- time_catg_info[[code]]
    time_parts <- strsplit(time_range, " to ")[[1]]
    time_parts <- gsub("a.m.", "AM", time_parts)
    time_parts <- gsub("p.m.", "PM", time_parts)
    start_time <- strptime(time_parts[1], format = "%I:%M %p")
    end_time <- strptime(time_parts[2], format = "%I:%M %p")
    
    # calc the middle of the time period
    if (!is.na(start_time) && !is.na(end_time)) {
      middle_time <- start_time + as.difftime(difftime(end_time, start_time, units = "mins") / 2, units = "mins")
      return(as.POSIXct(middle_time, format = "%Y-%m-%d %H:%M:%S"))
    } else {
      return(NA)
    }
  } else {
    return(NA)
  }
}

```

```{r}
typeof(convert_time_code("055", get_time("JWAP")))
# get_time("JWAP")
```

### API Call

##### TODO:

Data processing: Data cleaning: Subsetting data. Will add narrative on sunday.

```{r}
Pums_APIdata <- function(year=2022, num_variables =c("AGEP","PWGTP"),cat_variables="SEX",geography="ALL",Opt_subset=NULL){
  #Automatically capitalize our variables
  num_variables<-toupper(num_variables)
  cat_variables<-toupper(cat_variables)
  geography<-toupper(geography) 
  
  #Year Range Check
  if (year < 2010 | year > 2022){
    print("Invalid Year.  Acceptable year range: 2010-2022.")
    return()
    }
  
  #Numeric Variable check
  # changed as if should receive True of False
  valid_numeric_vars <- c("AGEP", "GASP", "GRPIP", "JWAP", "JWDP", "JWMNP", "PWGTP")
  if (!all(num_variables %in% valid_numeric_vars)) {
    stop("Invalid Numeric Variable(s). Choose from: ", paste(valid_numeric_vars, collapse = ", "))
  }
  
  #if PWGTP is the only variable, return error.
  if((length(num_variables) == 1 && num_variables == "PWGTP")){
    print("Need another numerical variable other than PWGTP")
    return()
  }
  
  #if PWGTP not in set, adds it
  if(!("PWGTP" %in% num_variables)){
    num_variables <-c(num_variables,"PWGTP")
  }
  
  #Categorical Variable Check
  if((length(cat_variables) == 0)){
    print("Need at least one categorical variable")
    return()
  }
  
  # cat variable choice check
  # changed as if should receive True of False
  valid_cat_vars <- c("FER", "HHL", "HISPEED", "JWTRNS", "SCH", "SCHL", "SEX")
  if (!all(cat_variables %in% valid_cat_vars)) {
    stop("Invalid categorical variable(s) specified. Choose from: ", paste(valid_cat_vars, collapse = ", "))
  }
  
  
  # Geography Check
  # changed as if should receive True of False
  valid_geography <- c("ALL", "REGION", "DIVISION", "STATE")
  if (!geography %in% valid_geography) {
    stop("Invalid Geography Variable. Choose from: ", paste(valid_geography, collapse = ", "))
  }

  
  #API key here:
  API_key<-"2b989c8e8efa3003c17e6eb0ca728a968e04a441" 
  
  
  #Adding num/cat variables to our url
  variables_url<-paste(c(num_variables,cat_variables),collapse=",")
  
  #Base URL w/ year variable
  base_pums_url <-paste0("https://api.census.gov/data/",year,"/acs/acs1/pums?get=",variables_url)
  
  if (!is.null(Opt_subset)) {
      #Adding geography to URL
      if (geography == "ALL"){
        full_url <- paste(base_pums_url,"&SCHL=24&key=",API_key,sep="")}
        else if (geography == "REGION"){
          full_url <- paste(base_pums_url,"&for=region:*&SCHL=24&key=",API_key,sep="")}
        else if (geography == "DIVISION"){
          full_url <- paste(base_pums_url,"for=division:*&SCHL=24&key=",API_key,sep="")}
        else if (geography == "STATE"){
          full_url <- paste(base_pums_url,"&for=state:*&SCHL=24&key=",API_key,sep="")}
    } else {
    full_url <- paste(base_pums_url,"&SCHL=24&key=",API_key,sep="")}

  
  #API Fetch:
  pums_fetch <- httr::GET(full_url)
  
  # Check for a successful response
  if (httr::status_code(pums_fetch) != 200) {
    stop("Failed to retrieve data. Check the API URL and parameters.")
  }
  
  #Decoding data: 
  #TODO: Need to use helper function here to do this part:

  pums_tibble <- convert_to_tibble(pums_fetch)
  #TODO: Clean data.  Fix column names etc...
  
  #TODO: Subset data for geography
  # I think you already did this subset while api request
  
  # convert numeric and time Variables
  valid_time_vars <- c("JWAP", "JWDP")
  for (col in colnames(pums_tibble)) {
    if (col %in% num_variables && !col %in% valid_time_vars) {
      # Convert to numeric
      pums_tibble[[col]] <- as.numeric(pums_tibble[[col]])
    } else if(col %in% valid_time_vars){
      pums_tibble[[col]] <- sprintf("%03d", as.numeric(pums_tibble[[col]]))
    }
  }
  
  # Convert JWAP and JWDP to Time
  if ("JWAP" %in% colnames(pums_tibble)) {
    pums_tibble$JWAP <- sapply(pums_tibble$JWAP, convert_time_code, time_catg_info = get_time("JWAP"))
    pums_tibble$JWAP <- as.POSIXct(pums_tibble$JWAP)
      }

  if ("JWDP" %in% colnames(pums_tibble)) {
      pums_tibble$JWDP <- sapply(pums_tibble$JWDP, convert_time_code, time_catg_info = get_time("JWDP"))
      pums_tibble$JWDP <- as.POSIXct(pums_tibble$JWDP)
  }

  
  # cat variables to factors
  factor_levels <- list(
    FER = c("0", "1", "2"),
    HHL = c("0", "1", "2", "3", "4", "5"),
    HISPEED = c("0", "1", "2"),
    JWTRNS = c("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"), # changed to remove pre-zero from each value
    SCH = c("0", "1", "2", "3"),
    SEX = c("1", "2")
  )
  
  for (col in colnames(pums_tibble)) {
    if (col %in% names(factor_levels)) {
      # Convert to factor with specified levels
      pums_tibble[[col]] <- factor(pums_tibble[[col]], levels = factor_levels[[col]])
    }
  }
  
  #Diagonostics: delete later
  print(paste("API URL:",full_url))
  print("Numeric Variables:")
  print(num_variables)
  print("Categorical Variables:")
  print(cat_variables)
  print(paste("Geography:",geography))
  
  
  #Returns tibble
  return(pums_tibble)
}
```

Testing exception cases/output:

```{r, echo=TRUE}
Pums_APIdata(2009)
#Pums_APIdata(2012)
Pums_APIdata(2012,num_variables="pwgtp")
Pums_APIdata(2012,num_variables ="agep")
Pums_APIdata(2012,num_variables="Agep",geography = "City")
```

```{r}
test <- Pums_APIdata(year = 2022, num_variables = c("AGEP", "JWAP", "JWDP"),cat_variables =c("SEX"))
test
```

### Lastly, write a function that allows the user to specify multiple years of survey data (and all the other

### options above)

```{r}
Pums_multiYearData <- function(years = 2022, num_variables = c("AGEP", "PWGTP"), 
                               cat_variables = "SEX", geography = "ALL", Opt_subset = NULL) {
  all_data <- purrr::map_dfr(years, ~ {
    year_data <- Pums_APIdata(year = .x, num_variables = num_variables, 
                              cat_variables = cat_variables, geography = geography, 
                              Opt_subset = Opt_subset)
    year_data$YEAR <- .x
    return(year_data)
  })
  
  return(all_data)
}
```

```{r}
multi_year_data <- Pums_multiYearData(years = c(2022,2021,2019), num_variables = c("AGEP", "PWGTP","JWAP"))
multi_year_data

```
